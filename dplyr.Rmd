---
title: "dplyr Tutorial"
author: "Ryan Stevens"
date: "9/30/2020"
output: pdf_document
---
# Data Wrangling: `dplyr` {#dplyr} 

```{r wrangling1, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(htmltools)
```

## Objectives & Resources

What are some common things you like to do with your data? Maybe remove rows or columns, do calculations and maybe add new columns? This is called **data wrangling**. It's not data management or data manipulation: you **keep the raw data raw** and do these things programatically in R with the tidyverse.

### Objectives

- discuss tidy data

### Resources 

Today's materials are borrowing from some excellent sources, including:
  
  - Jenny Bryan's lectures from STAT545 at UBC: [Introduction to dplyr](http://stat545.com/block009_dplyr-intro.html)
- Hadley Wickham and Garrett Grolemund's [R for Data Science](http://r4ds.had.co.nz/)
- Software Carpentry's R for reproducible scientific analysis materials: [Dataframe manipulation with dplyr](http://swcarpentry.github.io/r-novice-nyc/13-dplyr.html)
- First developed for [Software Carpentry at UCSB](http://remi-daigle.github.io/2016-04-15-UCSB/dplyr/)
- [RStudio's data wrangling cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf) 
- [RStudio's data wrangling webinar](https://www.rstudio.com/resources/webinars/data-wrangling-with-r-and-rstudio/) 

### Data and packages

**New York City Census data**

We'll be using New York City Census data provided by Prof. Roeper.  
   
We'll use the package `dplyr`, which is bundled within the `tidyverse` package. Please install the `tidyverse` ahead of time: 

```{r, eval=FALSE}
install.packages("tidyverse")
```


## Tidy Data

Let's start off discussing Tidy Data. 
   
   Hadley Wickham, RStudio's Chief Scientist, and his team have been building R packages for data wrangling and visualization based on the idea of **tidy data**. 

Tidy data has a simple convention: put variables in the columns and observations in the rows.

Right now we are going to use `dplyr` to wrangle this tidy-ish data set (the transform part of the cycle), and then come back to tidying messy data using `tidyr` once we've had some fun wrangling. These are both part of the `tidyverse` package that we've already.

### load `tidyverse` (which has `dplyr` inside)

```{r, eval=FALSE}
library(tidyverse)     ## install.packages("tidyverse")
```

This is becoming standard practice for how to load a library in a file, and if you get an error that the library doesn't exist, you can install the package easily by running the code within the comment (highlight `install.packages("tidyverse")` and run it).
   
## Explore the New York City Census dataset

   
### read data with `readr::read_csv()`
   
We need to read the data into R. The data file is called "New_York_City_Census.csv".
This data is in a specific type of format called a 'Comma Seperated Values' file,
hence why the file has the extension '.csv'. To read in a '.csv' file, we need
to tell R where it is located on our local machine (our computer).

We will use the `read_csv()` function from the `readr` package (part of the tidyverse, so it's already installed!). 

```{r, eval=FALSE}
## read nyc census. Note the readr:: prefix identifies which package it's in
nyc <- readr::read_csv('/Users/ryanstevens/ryan Dropbox/Ryan Stevens/fall2020/statistics/data/New_York_City_Census.csv') 
```

Let's use `head` and `tail`: 
```{r head, eval=FALSE}
head(nyc) # shows first 6
tail(nyc) # shows last 6

head(nyc, 10) # shows first X that you indicate
tail(nyc, 12) # guess what this does!
```

`str()` will provide a sensible description of almost anything: when in doubt, inspect using `str()` on some of the recently created objects to get some ideas about what to do next.
```{r str, eval=FALSE}
str(nyc) # ?str - displays the structure of an object
```

`nyc` is a `data.frame`. We aren't going to get into the other types of data receptacles today ('arrays', 'matrices'), because working with data.frames is what you should primarily use. Why?
  
  - data.frames package related variables neatly together, great for analysis
- most functions, including the latest and greatest packages actually __require__ that your data be in a data.frame
- data.frames can hold variables of different flavors such as
- character data (country or continent names; "Characters (chr)") 
- quantitative data (years, population; "Integers (int)" or "Numeric (num)")
- categorical information (male vs. female)

We can also see the `nyc` variable in RStudio's Environment pane (top right)

More ways to learn basic info on a data.frame. 
```{r names, eval=FALSE}
names(nyc)
dim(nyc)    # ?dim dimension
ncol(nyc)   # ?ncol number of columns
nrow(nyc)   # ?nrow number of rows
```

A statistical overview can be obtained with `summary()`, or with `skimr::skim()`
```{r summary, eval=FALSE}
summary(nyc)

library(skimr) # install.packages('skimr')
skim(nyc)
```

### Look at the variables inside a data.frame

To specify a single variable from a data.frame, use the dollar sign `$`. The `$` operator is a way to extract of replace parts of an object — check out the help menu for `$`. It's a common operator you'll see in R. 

```{r $, eval=FALSE}
nyc$Income # very long! hard to make sense of...
head(nyc$Income) # can do the same tests we tried before
str(nyc$Income) # it is a single numeric vector
summary(nyc$Income) # same information, formatted slightly differently
```


## `dplyr` basics

OK, so let's start wrangling with dplyr.

There are five `dplyr` functions that you will use to do the vast majority of data manipulations:
  
  - **`filter()`**: pick observations by their values

`r htmltools::img(src='img/rstudio-cheatsheet-filter.png', width=300)` 

- **`select()`**: pick variables by their names

`r htmltools::img(src='img/rstudio-cheatsheet-select.png', width=300)`

- **`mutate()`**: create new variables with functions of existing variables 

`r htmltools::img(src='img/rstudio-cheatsheet-mutate.png', width=300)`

- **`summarise()`**: collapse many values down to a single summary 

`r htmltools::img(src='img/rstudio-cheatsheet-summarise.png', width=300)`

- **`arrange()`**: reorder the rows

These can all be used in conjunction with `group_by()` which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These six functions provide the verbs for a language of data manipulation.

All verbs work similarly:
  
1. The first argument is a data frame.
2. The subsequent arguments describe what to do with the data frame. You can refer to columns in the data frame directly without using `$`.
3. The result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result.


## `filter()` subsets data row-wise (observations).

You will want to isolate bits of your data; maybe you want to only look at a single country or a few years. R calls this subsetting. 

`filter()` is a function in `dplyr` that takes logical expressions and returns the rows for which all are `TRUE`. 

Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 
  
  ![](img/rstudio-cheatsheet-filter.png)
Remember your logical expressions? We’ll use `<` and `==` here.

```{r, eval=FALSE}
filter(nyc, Income < 20000)
```

You can say this out loud: "Filter the nyc data for income less than 20000". Notice that when we do this, all the columns are returned, but only the rows that have the life expectancy less than 29. We've subsetted by row.

Let's try another: "Filter the nyc data for the borough Bronx".

```{r, eval=FALSE}
filter(nyc, Borough == "Bronx")
```

How about if we want two borough names? We can't use the `==` operator here, because it can only operate on one thing at a time. We will use the `%in%` operator: 

```{r, eval=FALSE}
filter(nyc, Borough %in% c("Bronx", "Manhattan"))
```

How about if we want Bronx residents with greater than 40000 dollars income? You can pass filter different criteria:

```{r, eval=FALSE}
filter(nyc, Borough == "Bronx", Income >= 40000)
```



  
## `select()` subsets data column-wise (variables)
  
We use `select()` to subset the data on variables or columns. 

Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 
  
  ![](img/rstudio-cheatsheet-select.png)

We can select multiple columns with a comma, after we specify the data frame (nyc). 

```{r, eval=FALSE}
select(nyc, Borough, Sex) 
```

We can also use - to deselect columns

```{r, eval=FALSE}
select(nyc, -Borough, -Sex) # you can use - to deselect columns
```

## Use `select()` and `filter()` together

Let's filter for Manhattan and remove the Sex column. We'll save this as a variable. Actually, as two temporary variables, which means that for the second one we need to operate on `gap_cambodia`, not `nyc`. 

```{r, eval=FALSE}
nyc_manhattan  <- filter(nyc, Borough == "Manhattan")
nyc_manhattan2 <- select(nyc_manhattan, -Sex) 
```

We also could have called them both `nyc_manhattan` and overwritten the first assignment. Either way, naming them and keeping track of them gets super cumbersome, which means more time to understand what's going on and opportunities for confusion or error.

Good thing there is an awesome alternative.

## Meet the new pipe `%>%` operator

Before we go any further, we should explore the new pipe operator that `dplyr` imports from the [`magrittr`](https://github.com/smbache/magrittr) package by Stefan Bache. **This is going to change your life**. You no longer need to enact multi-operation commands by nesting them inside each other. And we won't need to make temporary variables like we did in the Cambodia example above. This new syntax leads to code that is much easier to write and to read: it actually tells the story of your analysis.

Here's what it looks like: `%>%`. The RStudio keyboard shortcut: Ctrl + Shift + M (Windows), Cmd + Shift + M (Mac).

Let's demo then I'll explain:
```{r, eval=FALSE}
nyc %>% head()
```

This is equivalent to `head(nyc)`. This pipe operator takes the thing on the left-hand-side and __pipes__ it into the function call on the right-hand-side. It literally drops it in as the first argument.

Never fear, you can still specify other arguments to this function! To see the first 3 rows of nyc, we could say `head(nyc, 3)` or this:
```{r, eval=FALSE}
nyc %>% head(3)
```

**I've advised you to think "gets" whenever you see the assignment operator, `<-`. Similarly, you should think "and then" whenever you see the pipe operator, `%>%`.**
  
  One of the most awesome things about this is that you START with the data before you say what you're doing to DO to it. So above: "take the nyc data, and then give me the first three entries".

This means that instead of this:

```{r, eval=FALSE}

## instead of this...
nyc_manhattan  <- filter(nyc, Borough == "Manhattan")
nyc_manhattan2 <- select(nyc_manhattan, -Sex) 

## ...we can do this
nyc_manhattan  <- nyc %>% filter(Borough == "Manhattan")
nyc_manhattan2 <- nyc %>% select(-Sex) 
```

So you can see that we'll start with nyc in the first example line, and then nyc_manhattan in the second. This makes it a bit easier to see what data we are starting with and what we are doing to it.

...But, we still have those temporary variables so we're not truly that better off. But get ready to be majorly impressed:  


### Revel in the convenience

We can use the pipe to chain those two operations together:

```{r, eval=FALSE}
nyc_manhattan  <- nyc %>% 
                  filter(Borough == "Manhattan") %>% 
                  select(-Sex) 
```
  
  By using multiple lines I can actually read this like a story and there aren't temporary variables that get super confusing. In my head: 

>"start with the `nyc` data, and then  
filter for Manhattan, and then  
drop the variable Sex."

Being able to read a story out of code like this is really game-changing. We'll continue using this syntax as we learn the other dplyr verbs. 

## `mutate()` adds new variables

Alright, let's keep going. 

Let's say we needed to add an index column so we know which order these data came in. Let's not make a new variable, let's add a column to our nyc data frame. How do we do that? With the `mutate()` function. 

Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 
  
  ![](img/rstudio-cheatsheet-mutate.png)

Imagine we want to know if a resident is a Woman and lives in the Bronx

```{r, eval=FALSE}
nyc %>%
  mutate(bronx_woman = Borough=='Bronx' & Sex=='Female')
```

## `group_by()` operates on groups

What if we wanted to know the average income of each boroughs resident? Answering this question requires a **grouping variable**.

Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 
  
  ![](img/rstudio-cheatsheet-group_by.png)

By using `group_by()` we can set our grouping variable to `Borough` and create a new column called `mean_income` that will find the arithmetic mean (average) for
each borough

```{r, eval=FALSE}
nyc %>%
  group_by(Borough) %>% 
  mutate(mean_income = mean(Income))
```

OK, this is great. But what if we don't care about the other columns and we only want `mean_income` and `Borough` columns? Here's the next function: 
  
### `summarize()` with `group_by()`
  
We want to operate on a group, but actually collapse or distill the output from that group. The `summarize()` function will do that for us.

Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 
  
  ![](img/rstudio-cheatsheet-summarise.png)
Here we go:
  
```{r, eval=FALSE}
nyc %>%
  group_by(Borough) %>% 
  summarize(mean_income = mean(Income))
  ungroup()
```

How cool is that! `summarize()` will actually only keep the columns that are grouped_by or summarized. So if we wanted to keep other columns, we'd have to do have a few more steps (we'll get into it tomorrow). `ungroup()` removes the grouping and it's good to get in the habit of using it after a `group_by()`.

### Calculating percentages by group

Oftentimes, we want to calculate percentages of totals by group. For example,
we may want to calculate the percentage of people that travel to work that 
take a bicycle. We can break this down into a few steps:

1. Retrieve from the data only people that travel to work 
2. Count the number of people that take each mode of transportation
3. Divide (2) by the total number of people that travel to work

Let's put all of these steps together in one command:

```{r, eval=FALSE}
nyc %>%
  filter(Transportation_to_Work != 'Not working' & Transportation_to_Work!='Worked from Home') %>% 
  group_by(Transportation_to_Work) %>%
  tally() %>%
  ungroup() %>%
  mutate(perc_by_transport_mode=n/sum(n)) %>%
  filter(Transportation_to_Work=='Bicycle')
```

We can easily modify the above command to look at transportation by sub-groups.
Assume we want to know how different age groups travel to work. Let's first
bin people into age group bins. This is because we have few people who are 
exactly 25 years old, but we have many people that are between 20 and 29. 

```{r, eval=FALSE}
nyc = nyc %>% 
      mutate(age_bin = case_when(Age %in% 18:29 ~ '18-29',
                                 Age %in% 30:50 ~ '30-50',
                                 Age %in% 51:65 ~ '51-65',
                                 Age %in% 66:95 ~ '66-95'))
```

Now we can easily modify our command above to get the percentage of each of 
these groups that commute to work. 

```{r, eval=FALSE}
nyc %>%
  filter(Transportation_to_Work != 'Not working' & Transportation_to_Work!='Worked from Home') %>% 
  group_by(Transportation_to_Work,age_bin) %>%
  tally() %>%
  ungroup() %>%
  group_by(age_bin) %>%
  mutate(perc_by_transport_mode=n/sum(n)) %>%
  filter(Transportation_to_Work=='Bicycle')
```

### A Brief Interlude on Graphing

Let's say we want to graph our results from above. The package we will be using
is __ggplot__. This provides a lot of useful functionality, but we will only
be interested in very basic plotting exercises.

First, let's say we want to make a line chart of the percentage of people 
that commute to work on a bicycle by age bin? What is our x-axis? `age_bin`!
What is our y-axis? `perc_by_transport_mode`. Let's see how we would plot this:

```{r, eval=FALSE}

# Calculate percentage to work by age
perc_bike_by_age=nyc %>%
  filter(Transportation_to_Work != 'Not working' & Transportation_to_Work!='Worked from Home') %>% 
  group_by(Transportation_to_Work,age_bin) %>%
  tally() %>%
  ungroup() %>%
  group_by(age_bin) %>%
  mutate(perc_by_transport_mode=n/sum(n)) %>%
  filter(Transportation_to_Work=='Bicycle')

# Plot data as a line
ggplot(perc_bike_by_age,aes(x=age_bin,y=perc_by_transport_mode,group=1)) + 
  geom_line()

# Plot data as a dashed line
ggplot(perc_bike_by_age,aes(x=age_bin,y=perc_by_transport_mode,group=1)) + geom_line(linetype = "dashed")

# Plot data as points
ggplot(perc_bike_by_age,aes(x=age_bin,y=perc_by_transport_mode,group=1)) + geom_point()
```

We see from this that we can plot our data using many different types of lines.

Let's say we now want to do our plotting by groups. The easiest way to do this
is to use a grouping variable inside the aesthetics argument `aes`. Let's see
how to do this for the differences in Men versus Women. 

```{r, eval=FALSE}

# Calculate percentage to work by age
perc_bike_by_ageAndSex=nyc %>%
  filter(Transportation_to_Work != 'Not working' & Transportation_to_Work!='Worked from Home') %>% 
  group_by(Transportation_to_Work,age_bin,Sex) %>%
  tally() %>%
  ungroup() %>%
  group_by(age_bin,Sex) %>%
  mutate(perc_by_transport_mode=n/sum(n)) %>%
  filter(Transportation_to_Work=='Bicycle')

# Plot data as a line
ggplot(perc_bike_by_ageAndSex,aes(x=age_bin,y=perc_by_transport_mode,group=Sex,
                                  color=Sex)) + 
  geom_line()

# Plot data as two plots
ggplot(perc_bike_by_ageAndSex,aes(x=age_bin,y=perc_by_transport_mode,group=1)) + 
  facet_grid(.~Sex) +
  geom_line()

```
